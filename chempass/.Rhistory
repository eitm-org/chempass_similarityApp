property_df <- mutate(property_df, CID = as.character(CID))
syn_df <- cid_to_synonym(df_filt)
df_filt <- left_join(df_filt, property_df) # only common column here should be CID
df_filt <- left_join(df_filt, syn_df) # only common column here is CID
#' now to catch the missing names from titles
#' so this checks whether a CID has a title missing
#' and collects those missing into a new variable called missing_names
missing_names <- (df_filt[which(is.na(df_filt$Title)),])$input
if(length(missing_names) > 0) {
df_filt <- df_filt[-c(which(is.na(df_filt$Title))),]
}
df_filt <- df_filt %>% distinct(CID, .keep_all = TRUE)
merged_df <- df_filt
colnames(merged_df)[grep("Title", colnames(merged_df))] <- "Name"
missing_data(c(error_rows$input, missing_names))
#' is this needed if I use clean names somwhere else
#' check the difference here
merged_df$Name <- gsub(" ", "_", merged_df$Name)
merged_df$ROMol <- lapply(merged_df$SMILES, function(smiles) {
return(Chem$MolFromSmiles(smiles))
})
merged_df <- as.data.frame(merged_df)
View(merged_df)
fpgen <- AllChem$GetMorganGenerator(radius = as.integer(2), fpSize = as.integer(2048))
fingerprints <- list()
for (i in 1:nrow(merged_df)){
mol <- merged_df$ROMol[i]
fingerprints[[i]] <- fpgen$GetFingerprint(mol[[1]])
}
tanimoto_similarity_df = tanimoto_distance_matrix2(fingerprints)
tanimoto_similarity_df <- as.data.frame(tanimoto_similarity_df)
#print(dim(tanimoto_similarity_df))
tanimoto_distance <- 1 - tanimoto_similarity_df
colnames(tanimoto_distance) <- merged_df$Name
rownames(tanimoto_distance) <- merged_df$Name
View(tanimoto_similarity_df)
clusters = cluster_fingerprints(fingerprints, cutoff=0.5)
set.seed(4242)
metaMDS_results <- metaMDS(comm = tanimoto_distance,
autotransform = FALSE,
engine = "monoMDS",
k = 3,
weakties = FALSE,
model = "global",
maxit = 400,
try = 40,
trymax = 100)
set.seed(4242)
metaMDS_results <- metaMDS(comm = tanimoto_distance,
autotransform = FALSE,
engine = "monoMDS",
k = 2,
weakties = FALSE,
model = "global",
maxit = 400,
try = 40,
trymax = 100)
metaMDS_results.points <- data.frame(metaMDS_results$points)
metaMDS_results.points$cluster_ID <- merged_df$cluster_membership
metaMDS_results.points$Name <- merged_df$Name
#print(head(metaMDS_results.points))
metaMDS_results.points <- metaMDS_results.points %>% mutate(cluster_ID = as.character(cluster_ID))
metaMDS_results.points %>%
ggplot(., aes(x = MDS1, y = MDS3)) +
geom_point(size = 2, col = "grey") +
#geom_point(data = filter(metaMDS_results.points, cluster_ID_toPlot == "plot"), aes(x = MDS1, y = MDS3, col = cluster_ID), size = 4) +
#scale_color_manual(values = c('#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666')) +
theme_classic() +
theme(text = element_text(size = 15)) +
labs(title = "NMDS Plot from Distance Matrix",
x = "MDS1",
y = "MDS2")
metaMDS_results.points %>%
ggplot(., aes(x = MDS1, y = MDS2)) +
geom_point(size = 2, col = "grey") +
#geom_point(data = filter(metaMDS_results.points, cluster_ID_toPlot == "plot"), aes(x = MDS1, y = MDS3, col = cluster_ID), size = 4) +
#scale_color_manual(values = c('#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666')) +
theme_classic() +
theme(text = element_text(size = 15)) +
labs(title = "NMDS Plot from Distance Matrix",
x = "MDS1",
y = "MDS2")
metaMDS_results.points %>%
ggplot(., aes(x = MDS1, y = MDS2)) +
geom_point(size = 2, col = "grey") +
#geom_point(data = filter(metaMDS_results.points, cluster_ID_toPlot == "plot"), aes(x = MDS1, y = MDS3, col = cluster_ID), size = 4) +
#scale_color_manual(values = c('#7fc97f','#beaed4','#fdc086','#ffff99','#386cb0','#f0027f','#bf5b17','#666666')) +
theme_classic() +
theme(text = element_text(size = 15)) +
labs(title = "NMDS Plot from Distance Matrix",
x = "MDS1",
y = "MDS2")
nrow(tanimoto_distance)
mixed_input <- read.csv("/Users/kdabke/Downloads/CHEMPASS-test.csv", header = FALSE, stringsAsFactors = FALSE)
mixed_input$DTXSID <- grepl("DTXSID", mixed_input$V1)
numbers_only <- function(x) !grepl("\\D", x)
mixed_input$CID <- numbers_only(mixed_input$V1)
dtxsid_df <- filter(mixed_input, DTXSID == TRUE)
dtxsid_df <- subset(dtxsid_df, select = V1)
cid_df <- filter(mixed_input, CID == TRUE)
cid_df <- subset(cid_df, select = V1)
smiles_df <- filter(mixed_input, DTXSID == FALSE & CID == FALSE)
smiles_df <- subset(smiles_df, select = V1)
if (dim(dtxsid_df)[1] > 0){
df1 <- dtxsid_pubchem(dtxsid_df)
}
#' this could be a smiles function
#' usage eg:
#' df2 <- smiles_pubchem(smiles_df)
if (dim(smiles_df)[1] > 0){
df2 <- smiles_pubchem(smiles_df)
}
#' this would be a CID function
#' usage example
#' df3 <- input_cid_reformating(cid_df)
if (dim(cid_df)[1] > 0){
df3 <- input_cid_reformating(cid_df)
}
dfs_list <- list()
if (exists("df1")) dfs_list$df1 <- df1
if (exists("df2")) dfs_list$df2 <- df2
if (exists("df3")) dfs_list$df3 <- df3
#' this could also be a function in itself
#' usage example
#' merged_df <- cid_processing(dfs_list)
df <- bind_rows(dfs_list)
error_rows <- df %>%
filter(if_any(everything(), ~ . == 'error'))
df_filt <- filter(df, !(input %in% error_rows$input))
df_filt <- subset(df_filt, select = -c(TITLE))
#' mutates the cid into a character
df_filt <- mutate(df_filt, CID = as.character(CID))
df_filt <- df_filt %>% distinct(CID, .keep_all = TRUE)
# get properties from Pubchem
property_df <- tryCatch({
get_properties_from_CIDs(paste(df_filt$CID, collapse = ","))
}, error = function(e) {
#message("Retrying once after error...")
Sys.sleep(1)
tryCatch(get_properties_from_CIDs(paste(df_filt$CID, collapse = ",")), error = function(e2) {
#message("Second attempt failed.")
"error"
})
})
#' re-enforces that the CIDs is a character column
#' this is to ensure left join works downstream
property_df <- mutate(property_df, CID = as.character(CID))
syn_df <- cid_to_synonym(df_filt)
df_filt <- left_join(df_filt, property_df) # only common column here should be CID
df_filt <- left_join(df_filt, syn_df) # only common column here is CID
View(mixed_input)
#' now to catch the missing names from titles
#' so this checks whether a CID has a title missing
#' and collects those missing into a new variable called missing_names
missing_names <- (df_filt[which(is.na(df_filt$Title)),])$input
df_filt <- df_filt %>% distinct(CID, .keep_all = TRUE)
merged_df <- df_filt
colnames(merged_df)[grep("Title", colnames(merged_df))] <- "Name"
merged_df$Name <- gsub(" ", "_", merged_df$Name)
merged_df$ROMol <- lapply(merged_df$SMILES, function(smiles) {
return(Chem$MolFromSmiles(smiles))
})
merged_df <- as.data.frame(merged_df)
fpgen <- AllChem$GetMorganGenerator(radius = as.integer(2), fpSize = as.integer(2048))
fingerprints <- list()
for (i in 1:nrow(merged_df)){
mol <- merged_df$ROMol[i]
fingerprints[[i]] <- fpgen$GetFingerprint(mol[[1]])
}
tanimoto_similarity_df = tanimoto_distance_matrix2(fingerprints)
tanimoto_similarity_df <- as.data.frame(tanimoto_similarity_df)
#print(dim(tanimoto_similarity_df))
tanimoto_distance <- 1 - tanimoto_similarity_df
colnames(tanimoto_distance) <- merged_df$Name
rownames(tanimoto_distance) <- merged_df$Name
clusters = cluster_fingerprints(fingerprints, cutoff=0.5)
View(clusters)
set.seed(4242)
metaMDS_results <- metaMDS(comm = tanimoto_distance,
autotransform = FALSE,
engine = "monoMDS",
k = 2,
weakties = FALSE,
model = "global",
maxit = 400,
try = 40,
trymax = 100)
metaMDS_results <- metaMDS(comm = tanimoto_distance,
autotransform = FALSE,
engine = "monoMDS",
k = 3,
weakties = FALSE,
model = "global",
maxit = 400,
try = 40,
trymax = 100)
if (nrow(tanimoto_distance) == 1) {
print("display a specific message")
}ifelse(nrow(tanimoto_distance) <= 3 & nrow(tanimoto_distance) > 1){
if (nrow(tanimoto_distance) == 1) {
print("display a specific message")
}else if (nrow(tanimoto_distance) <= 3 & nrow(tanimoto_distance) > 1){
set.seed(4242)
metaMDS_results <- metaMDS(comm = tanimoto_distance,
autotransform = FALSE,
engine = "monoMDS",
k = 2,
weakties = FALSE,
model = "global",
maxit = 400,
try = 40,
trymax = 100)
}else{
set.seed(4242)
metaMDS_results <- metaMDS(comm = tanimoto_distance,
autotransform = FALSE,
engine = "monoMDS",
k = 3,
weakties = FALSE,
model = "global",
maxit = 400,
try = 40,
trymax = 100)
}
runApp()
mixed_input <- read.csv("/Users/kdabke/Downloads/CHEMPASS-test.csv", header = FALSE, stringsAsFactors = FALSE)
mixed_input$DTXSID <- grepl("DTXSID", mixed_input$V1)
numbers_only <- function(x) !grepl("\\D", x)
mixed_input$CID <- numbers_only(mixed_input$V1)
dtxsid_df <- filter(mixed_input, DTXSID == TRUE)
dtxsid_df <- subset(dtxsid_df, select = V1)
cid_df <- filter(mixed_input, CID == TRUE)
cid_df <- subset(cid_df, select = V1)
smiles_df <- filter(mixed_input, DTXSID == FALSE & CID == FALSE)
smiles_df <- subset(smiles_df, select = V1)
if (dim(dtxsid_df)[1] > 0){
df1 <- dtxsid_pubchem(dtxsid_df)
}
#' this could be a smiles function
#' usage eg:
#' df2 <- smiles_pubchem(smiles_df)
if (dim(smiles_df)[1] > 0){
df2 <- smiles_pubchem(smiles_df)
}
#' this would be a CID function
#' usage example
#' df3 <- input_cid_reformating(cid_df)
if (dim(cid_df)[1] > 0){
df3 <- input_cid_reformating(cid_df)
}
dfs_list <- list()
if (exists("df1")) dfs_list$df1 <- df1
if (exists("df2")) dfs_list$df2 <- df2
if (exists("df3")) dfs_list$df3 <- df3
#' this could also be a function in itself
#' usage example
#' merged_df <- cid_processing(dfs_list)
df <- bind_rows(dfs_list)
error_rows <- df %>%
filter(if_any(everything(), ~ . == 'error'))
df_filt <- filter(df, !(input %in% error_rows$input))
df_filt <- subset(df_filt, select = -c(TITLE))
#' mutates the cid into a character
df_filt <- mutate(df_filt, CID = as.character(CID))
df_filt <- df_filt %>% distinct(CID, .keep_all = TRUE)
# get properties from Pubchem
property_df <- tryCatch({
get_properties_from_CIDs(paste(df_filt$CID, collapse = ","))
}, error = function(e) {
#message("Retrying once after error...")
Sys.sleep(1)
tryCatch(get_properties_from_CIDs(paste(df_filt$CID, collapse = ",")), error = function(e2) {
#message("Second attempt failed.")
"error"
})
})
#' re-enforces that the CIDs is a character column
#' this is to ensure left join works downstream
property_df <- mutate(property_df, CID = as.character(CID))
syn_df <- cid_to_synonym(df_filt)
df_filt <- left_join(df_filt, property_df) # only common column here should be CID
df_filt <- left_join(df_filt, syn_df) # only common column here is CID
#' now to catch the missing names from titles
#' so this checks whether a CID has a title missing
#' and collects those missing into a new variable called missing_names
missing_names <- (df_filt[which(is.na(df_filt$Title)),])$input
#' if there are missing_names, it removes the entire row from the datafrmae
#' this ensures that downstream, the CIDs that get processed are clean
if(length(missing_names) > 0) {
df_filt <- df_filt[-c(which(is.na(df_filt$Title))),]
}
#' checks the data frame for duplicate CIDs after all the processing
df_filt <- df_filt %>% distinct(CID, .keep_all = TRUE)
merged_df <- df_filt
colnames(merged_df)[grep("Title", colnames(merged_df))] <- "Name"
#' saves the error and missing CIDs and names
#' is it possible to show here the missing input instead
#' might be better for user
#' is this needed if I use clean names somwhere else
#' check the difference here
merged_df$Name <- gsub(" ", "_", merged_df$Name)
merged_df$ROMol <- lapply(merged_df$SMILES, function(smiles) {
return(Chem$MolFromSmiles(smiles))
})
merged_df <- as.data.frame(merged_df)
fpgen <- AllChem$GetMorganGenerator(radius = as.integer(2), fpSize = as.integer(2048))
fingerprints <- list()
for (i in 1:nrow(merged_df)){
mol <- merged_df$ROMol[i]
fingerprints[[i]] <- fpgen$GetFingerprint(mol[[1]])
}
tanimoto_similarity_df = tanimoto_distance_matrix2(fingerprints)
tanimoto_similarity_df <- as.data.frame(tanimoto_similarity_df)
#print(dim(tanimoto_similarity_df))
tanimoto_distance <- 1 - tanimoto_similarity_df
colnames(tanimoto_distance) <- merged_df$Name
rownames(tanimoto_distance) <- merged_df$Name
clusters = cluster_fingerprints(fingerprints, cutoff=0.5)
ylgnbu_col <- sequential_hcl(9, "YlGnBu")
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2) + 0.1)
hmap <- Heatmap(
as.matrix(tanimoto_distance),
show_row_names = T,
show_column_names = F,
#row_names_gp = gpar(col = ifelse(rownames(distance_matrix) %in% (filter(merged_data, type == "new"))$`chemical names`, "blue", "black")),
cluster_rows = T,
cluster_columns = T,
show_column_dend = T,
show_row_dend = T,
row_dend_reorder = T,
column_dend_reorder = T,
clustering_method_rows = "ward.D2", #top_annotation = colAnn,
clustering_method_columns = "ward.D2",col = ylgnbu_col,
width = unit(150, "mm"),border = TRUE,
heatmap_legend_param = list(
title = "Tanimoto Distance",
title_position = "leftcenter-rot",
labels_gp = gpar(fontsize = 12),
title_gp = gpar(fontsize = 12)),
column_gap=unit(1, "mm"))
runApp()
runApp()
runApp()
mixed_input <- read.csv("/Users/kdabke/Downloads/CHEMPASS-test_og.csv", header = FALSE, stringsAsFactors = FALSE)
mixed_input$DTXSID <- grepl("DTXSID", mixed_input$V1)
numbers_only <- function(x) !grepl("\\D", x)
mixed_input$CID <- numbers_only(mixed_input$V1)
dtxsid_df <- filter(mixed_input, DTXSID == TRUE)
dtxsid_df <- subset(dtxsid_df, select = V1)
cid_df <- filter(mixed_input, CID == TRUE)
cid_df <- subset(cid_df, select = V1)
smiles_df <- filter(mixed_input, DTXSID == FALSE & CID == FALSE)
smiles_df <- subset(smiles_df, select = V1)
if (dim(dtxsid_df)[1] > 0){
df1 <- dtxsid_pubchem(dtxsid_df)
}
#' this could be a smiles function
#' usage eg:
#' df2 <- smiles_pubchem(smiles_df)
if (dim(smiles_df)[1] > 0){
df2 <- smiles_pubchem(smiles_df)
}
#' this would be a CID function
#' usage example
#' df3 <- input_cid_reformating(cid_df)
if (dim(cid_df)[1] > 0){
df3 <- input_cid_reformating(cid_df)
}
dfs_list <- list()
if (exists("df1")) dfs_list$df1 <- df1
if (exists("df2")) dfs_list$df2 <- df2
if (exists("df3")) dfs_list$df3 <- df3
#' this could also be a function in itself
#' usage example
#' merged_df <- cid_processing(dfs_list)
df <- bind_rows(dfs_list)
error_rows <- df %>%
filter(if_any(everything(), ~ . == 'error'))
df_filt <- filter(df, !(input %in% error_rows$input))
df_filt <- subset(df_filt, select = -c(TITLE))
#' mutates the cid into a character
df_filt <- mutate(df_filt, CID = as.character(CID))
df_filt <- df_filt %>% distinct(CID, .keep_all = TRUE)
# get properties from Pubchem
property_df <- tryCatch({
get_properties_from_CIDs(paste(df_filt$CID, collapse = ","))
}, error = function(e) {
#message("Retrying once after error...")
Sys.sleep(1)
tryCatch(get_properties_from_CIDs(paste(df_filt$CID, collapse = ",")), error = function(e2) {
#message("Second attempt failed.")
"error"
})
})
#' re-enforces that the CIDs is a character column
#' this is to ensure left join works downstream
property_df <- mutate(property_df, CID = as.character(CID))
syn_df <- cid_to_synonym(df_filt)
df_filt <- left_join(df_filt, property_df) # only common column here should be CID
df_filt <- left_join(df_filt, syn_df) # only common column here is CID
#' now to catch the missing names from titles
#' so this checks whether a CID has a title missing
#' and collects those missing into a new variable called missing_names
missing_names <- (df_filt[which(is.na(df_filt$Title)),])$input
#' if there are missing_names, it removes the entire row from the datafrmae
#' this ensures that downstream, the CIDs that get processed are clean
if(length(missing_names) > 0) {
df_filt <- df_filt[-c(which(is.na(df_filt$Title))),]
}
#' checks the data frame for duplicate CIDs after all the processing
df_filt <- df_filt %>% distinct(CID, .keep_all = TRUE)
merged_df <- df_filt
colnames(merged_df)[grep("Title", colnames(merged_df))] <- "Name"
#' saves the error and missing CIDs and names
#' is it possible to show here the missing input instead
#' might be better for user
#' is this needed if I use clean names somwhere else
#' check the difference here
merged_df$Name <- gsub(" ", "_", merged_df$Name)
merged_df$ROMol <- lapply(merged_df$SMILES, function(smiles) {
return(Chem$MolFromSmiles(smiles))
})
merged_df <- as.data.frame(merged_df)
fpgen <- AllChem$GetMorganGenerator(radius = as.integer(2), fpSize = as.integer(2048))
fingerprints <- list()
for (i in 1:nrow(merged_df)){
mol <- merged_df$ROMol[i]
fingerprints[[i]] <- fpgen$GetFingerprint(mol[[1]])
}
tanimoto_similarity_df = tanimoto_distance_matrix2(fingerprints)
tanimoto_similarity_df <- as.data.frame(tanimoto_similarity_df)
#print(dim(tanimoto_similarity_df))
tanimoto_distance <- 1 - tanimoto_similarity_df
colnames(tanimoto_distance) <- merged_df$Name
rownames(tanimoto_distance) <- merged_df$Name
clusters = cluster_fingerprints(fingerprints, cutoff=0.5)
ylgnbu_col <- sequential_hcl(9, "YlGnBu")
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2) + 0.1)
if (nrow(tanimoto_distance) == 1) {
print("something")
}else{
hmap <- Heatmap(
as.matrix(tanimoto_distance),
show_row_names = T,
show_column_names = F,
#row_names_gp = gpar(col = ifelse(rownames(distance_matrix) %in% (filter(merged_data, type == "new"))$`chemical names`, "blue", "black")),
cluster_rows = T,
cluster_columns = T,
show_column_dend = T,
show_row_dend = T,
row_dend_reorder = T,
column_dend_reorder = T,
clustering_method_rows = "ward.D2", #top_annotation = colAnn,
clustering_method_columns = "ward.D2",col = ylgnbu_col,
width = unit(150, "mm"),border = TRUE,
heatmap_legend_param = list(
title = "Tanimoto Distance",
title_position = "leftcenter-rot",
labels_gp = gpar(fontsize = 12),
title_gp = gpar(fontsize = 12)),
column_gap=unit(1, "mm"))
#ht = draw(hmap, heatmap_legend_side="left", annotation_legend_side="bottom")
heatmap_slot(hmap)
}
if (nrow(tanimoto_distance) == 1) {
print("something")
}else{
hmap <- Heatmap(
as.matrix(tanimoto_distance),
show_row_names = T,
show_column_names = F,
#row_names_gp = gpar(col = ifelse(rownames(distance_matrix) %in% (filter(merged_data, type == "new"))$`chemical names`, "blue", "black")),
cluster_rows = T,
cluster_columns = T,
show_column_dend = T,
show_row_dend = T,
row_dend_reorder = T,
column_dend_reorder = T,
clustering_method_rows = "ward.D2", #top_annotation = colAnn,
clustering_method_columns = "ward.D2",col = ylgnbu_col,
width = unit(150, "mm"),border = TRUE,
heatmap_legend_param = list(
title = "Tanimoto Distance",
title_position = "leftcenter-rot",
labels_gp = gpar(fontsize = 12),
title_gp = gpar(fontsize = 12)),
column_gap=unit(1, "mm"))
#ht = draw(hmap, heatmap_legend_side="left", annotation_legend_side="bottom")
}
hmap
nrow(tanimoto_distance)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
